# MYSQL基本特征及优化

## 事务的基本特征
#### 原子性（atomicity）:
     一个事务必须视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，
     对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性
     
#### 一致性（consistency）:
	数据库总数从一个一致性的状态转换到另一个一致性的状态

#### 隔离性（isolation）:
	一个事务所做的修改在最终提交以前，对其他事务是不可见的

#### 持久性（durability）:
	一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。



## 事务的隔离级别 (Mysql的默认隔离级别是Repeatable read)
#### 读未提交(Read uncommitted):
	一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证

#### 读已提交(Read committed):
	一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生

#### 可重复读(Repeatable read):
	就是在开始读取数据（事务开启）时，不再允许修改操作，可避免脏读、不可重复读的发生

#### 串行(Serializable):
	是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。
	但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用


## 脏读、不可重复读、幻读的解释

#### 脏读：
	事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据；
#### 不可重复读：
	事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，
	导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致；
#### 幻读：
	幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）


## 表结构的优化

#### 数据表类型
	MyIASM、InnoDB、HEAP、ISAM、MERGE、DBD、Gemeni(一般只知道MyIASM、InnoDB即可)

#### innodb引擎的4大特性
	插入缓冲(insert buffer)、二次写(double write)、自适应哈希索引(ahi)、预读(read ahead)


#### InnoDB引擎的行锁是基于索引

### Mysql中的myisam与innodb的区别
	InooDB支持事务，而MyISAM不支持事务；

	InnoDB支持行级锁，而MyISAM支持表级锁；

	InnoDB支持MVCC，而MyISAM不支持；

	InnoDB支持外键，而MyISAM不支持；

	InnoDB不支持全文索引，而MyISAM支持；

	InnoDB不能通过直接拷贝表文件的方法拷贝表到另外一台机器， myisam 支持；

	InnoDB表支持多种行格式， myisam 不支持；

	InnoDB是索引组织表， myisam 是堆表；


#### myisam与innodb 执行select count(*) myisam更快，因为myisam内部维护了一个计数器，可以直接调取。

### sql语句优化
	避免select *，将需要查找的字段列出来；

	使用连接（join）来代替子查询；

	拆分大的delete或insert语句；

	使用limit对查询结果的记录进行限定；

	不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，
	否则系统将可能无法正确使用索引尽量避免在where 子句中对字段进行 null 值判断，
	否则将导致引擎放弃使用索引而进行全表扫描；

	尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描；

	尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描；

### 表结构优化
	ID 所有建表的时候设置主键；

	选择正确的存储引擎 ;

	使用可存下数据的最小的数据类型，整型 < date,time < char,varchar < blob；

	使用简单的数据类型，整型比字符处理开销更小，因为字符串的比较更复杂。如，int类型存储时间类型，bigint类型转ip函数；

	使用合理的字段属性长度，固定长度的表会更快。

	使用enum、char而不是varchar；

	尽可能使用not null定义字段(给空字段设置默认值)；

	尽量少用text;

	给频繁使用和查询的字段建立合适的索引；

### mysql常用的函数:
	sum(和)、count（计数几条） 、avg（平均值）、min（最小值）、max（最大值）

## 常用的命令 Explain、describe、show、truncate

#### Explain使用方法：
	EXPLAIN SELECT user_id from orders where user_id=1
	查看explain.md  
	
#### DESCRIBE：
	查看表结构 DESCRIBE orders;
	
#### show：
	跟DESCRIBE是一样的只是语法不一样，查看表结构 show columns from  orders;
	
#### Truncate
      是一个能够快速清空资料表内所有资料的SQL语法。并且能针对具有自动递增值的字段，做计数重置归零重新计算的作用。
      
      
#### 删除数据程度从强到弱
      1、drop  table orders 
      drop将表格直接删除，没有办法找回
      将删除表的结构、被依赖的约束(constrain)、触发器 (trigger)、索引(index);
      依赖于该表的存储过程/函数将保留,但是变为invalid状态。
      
      2、truncate orders
      删除表中的所有数据，不能与where一起使用
      删除表中的所有行，但表结构及其列、约束、索引字段等保持不变。
      新行标识所用的计数值重置为该列的种子（自增ID会重置，重新开始）。
      执行速度比delete快
      
      3、delete from orders where id=1
      删除表中的数据(可制定某一行)

## 常用的关键字：
#### distinct（去重）、group by（对结果集进行分组）
      group by的执行速度比group by快

#### limit（返回的数据数量）、offset（配合limit使用）
      比如有三条记录（1，2，3）

      limit后面跟的是2条数据，offset后面是从第1条开始读取，结果（2，3）
      SELECT  id  FROM  orders order by id LIMIT 2 OFFSET 1; 


      limit后面是从第2条开始读，读取1条信息。，结果（3）
      SELECT  goods_id  FROM  so_cat order by goods_id LIMIT 2,1;  


#### union、union all（连接两个以上SELECT语句）
      UNION 在进行表链接后会筛选掉重复的记录，将会按照字段的顺序进行排序，
      UNION ALL 不会去除重复记录，只是简单的将两个结果合并后就返回，从效率上说，UNION ALL 要比UNION快很多
      
#### order by(排序)、between（两个值之间的数据范围内的值。这些值可以是数值、文本或者日期。）


### varchar(100)和varchar(200)的区别
      varchar(100)最多存放100个字符，varchar(200)最多存放200个字符，
      varchar(100)和(200)存储hello所占空间一样，
      但varchar(200)在排序时会消耗更多内存，
      因为order by col采用fixed_length计算col长度(memory引擎也一样)
    
### varchar(20)和int(20)中的20含义区别：
      varchar(20)表示最多存放20个字符，
      int(20)表示最多显示20个字符，但是存储空间还是占4字节存储，存储范围不变；
      
      
### 存储过程与触发器的区别
      触发器与存储过程非常相似，触发器也是SQL语句集，
      存储过程用EXECUTE语句调用，触发器是在用户执行Transact-SQL语句时自动触发（激活）执行。
      触发器是在一个修改了指定表中的数据时执行的存储过程。
      通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。
      由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。
      触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。
      当对某一表进行诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会自动执行触发器所定义的SQL语句，
      从而确保对数据的处理必须符合这些SQL语句所定义的规则。
      
## MySQL主要的索引类型
#### 普通索引
      是最基本的索引，它没有任何限制；
#### 唯一索引
      索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一；
#### 主键索引
      是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值；
#### 组合索引
      指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合；
#### 全文索引
      主要用来查找文本中的关键字，而不是直接与索引中的值相比较，mysql中MyISAM支持全文索引而InnoDB不支持；
      
### 索引优点缺点
      索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。
      它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。
      索引可以是唯一的，创建索引允许指定单个列或者是多个列。
      缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小
      
#### 使用like使用索引      
      使用 like 'a%' 会用到索引
      使用 like'%a' 不会用到索引
      使用 like'%a%' 不会用到索引

#### 使用索引注意事项
      索引不会包含有NULL的列，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的；
      使用短索引，对串列进行索引，如果可以就应该指定一个前缀长度；
      短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作；
      mysql查询只使用一个索引，因此数据库默认排序可以符合要求的情况下不要使用排序操作，
      尽量不要包含多个列的排序，如果需要最好给这些列建复合索引；
      注意like，上面已经提到；不要在列上进行运算；
      不使用NOT IN 、<>、！=操作，但<,<=，=，>,>=,BETWEEN,IN是可以用到索引的；
      索引要建立在经常进行select操作的字段上；
      索引要建立在值比较唯一的字段上；
      对于那些定义为text、image和bit数据类型的列不应该增加索引；
      在where和join中出现的列需要建立索引；
      如果where字句的查询条件里使用了函数(如：where DAY(column)=…),mysql将无法使用索引；
      在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用；
      
